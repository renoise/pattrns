#pragma once

/* This file is autogenerated by cbindgen. Do not modify manually. */

#include <cstdint>
#include <cassert>
#include <memory>

namespace pattrns {

/// Instrument_id value which refers to an unset, undefined id.
constexpr static const uint32_t NO_INSTRUMENT_ID = UINT32_MAX;

/// Parameter change value which refers to an empty, undefined parameter.
constexpr static const uint32_t NO_PARAMETER_ID = UINT32_MAX;

/// Instrument_id value which refers to an unset, undefined glide value.
constexpr static const float NO_GLIDE_VALUE = -1.0;

/// Note value which refers to an empty, undefined note.
constexpr static const uint8_t EMPTY_NOTE = 254;

/// Note value which should turn off notes playing on the same column
constexpr static const uint8_t NOTE_OFF = 255;

/// C lang compatible representation of a rust `pattrns::ParameterType`.
enum class ParameterType {
  Boolean,
  Integer,
  Float,
  Enum,
};

/// C lang compatible representation of a rust `pattrns::Pattern`.
struct Pattern;

/// C lang compatible representation of a rust `Vec<String>` using a C Array.
struct ValueStrings {
  const char *const *strings_ptr;
  uint32_t strings_len;
};

/// C lang compatible representation of a rust `pattrns::Parameter`.
/// Ensure strings are not used after the parameters array got dropped.
struct Parameter {
  const char *id;
  const char *name;
  const char *description;
  ParameterType parameter_type;
  double min;
  double max;
  double default_;
  double value;
  ValueStrings value_strings;
};

/// C lang compatible representation of a rust `ParameterMap` using a C Array.
struct ParameterSet {
  const Parameter *parameters_ptr;
  uint32_t parameters_len;
};

/// C lang compatible Result<Pattern, String> representation for new_pattern_from_string/file.
/// Error Strings must be deleted with `drop_error_string`.
/// Pattern values must be deleted with `drop_pattern`,
struct PatternResult {
  enum class Tag {
    Error,
    Value,
  };

  struct Error_Body {
    const char *_0;
  };

  struct Value_Body {
    Pattern *_0;
  };

  Tag tag;
  union {
    Error_Body error;
    Value_Body value;
  };

  static PatternResult Error(const char *const &_0) {
    PatternResult result;
    ::new (&result.error._0) (const char*)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const char*const & AsError() const {
    assert(IsError());
    return error._0;
  }

  static PatternResult Value(Pattern *const &_0) {
    PatternResult result;
    ::new (&result.value._0) (Pattern*)(_0);
    result.tag = Tag::Value;
    return result;
  }

  bool IsValue() const {
    return tag == Tag::Value;
  }

  Pattern*const & AsValue() const {
    assert(IsValue());
    return value._0;
  }
};

/// C lang compatible representation of a rust `pattrns::BeatTimeBase`.
struct Timebase {
  float bpm;
  uint32_t bpb;
  uint32_t sample_rate;
};

/// C lang compatible representation of a rust `Result<ParameterSet>`.
/// Error strings must be released manually with `drop_error_string`.
/// Values must be released manually with `drop_parameter_set`.
struct ParameterSetResult {
  enum class Tag {
    Error,
    Value,
  };

  struct Error_Body {
    const char *_0;
  };

  struct Value_Body {
    ParameterSet *_0;
  };

  Tag tag;
  union {
    Error_Body error;
    Value_Body value;
  };

  static ParameterSetResult Error(const char *const &_0) {
    ParameterSetResult result;
    ::new (&result.error._0) (const char*)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const char*const & AsError() const {
    assert(IsError());
    return error._0;
  }

  static ParameterSetResult Value(ParameterSet *const &_0) {
    ParameterSetResult result;
    ::new (&result.value._0) (ParameterSet*)(_0);
    result.tag = Tag::Value;
    return result;
  }

  bool IsValue() const {
    return tag == Tag::Value;
  }

  ParameterSet*const & AsValue() const {
    assert(IsValue());
    return value._0;
  }
};

/// C lang compatible representation of a rust `Result<()>`.
/// Error strings must be released manually with `drop_error_string`.
struct VoidResult {
  enum class Tag {
    Error,
    Ok,
  };

  struct Error_Body {
    const char *_0;
  };

  struct Ok_Body {

  };

  Tag tag;
  union {
    Error_Body error;
    Ok_Body ok;
  };

  static VoidResult Error(const char *const &_0) {
    VoidResult result;
    ::new (&result.error._0) (const char*)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const char*const & AsError() const {
    assert(IsError());
    return error._0;
  }

  static VoidResult Ok() {
    VoidResult result;
    result.tag = Tag::Ok;
    return result;
  }

  bool IsOk() const {
    return tag == Tag::Ok;
  }
};

/// C lang compatible representation of a rust `Result<f64>`.
/// Error strings must be released manually with `drop_error_string`.
struct F64Result {
  enum class Tag {
    Error,
    Value,
  };

  struct Error_Body {
    const char *_0;
  };

  struct Value_Body {
    double _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Value_Body value;
  };

  static F64Result Error(const char *const &_0) {
    F64Result result;
    ::new (&result.error._0) (const char*)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const char*const & AsError() const {
    assert(IsError());
    return error._0;
  }

  static F64Result Value(const double &_0) {
    F64Result result;
    ::new (&result.value._0) (double)(_0);
    result.tag = Tag::Value;
    return result;
  }

  bool IsValue() const {
    return tag == Tag::Value;
  }

  const double& AsValue() const {
    assert(IsValue());
    return value._0;
  }
};

/// C lang compatible representation of a rust `Result<u32>`.
/// Error strings must be released manually with `drop_error_string`.
struct UInt32Result {
  enum class Tag {
    Error,
    Value,
  };

  struct Error_Body {
    const char *_0;
  };

  struct Value_Body {
    uint32_t _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Value_Body value;
  };

  static UInt32Result Error(const char *const &_0) {
    UInt32Result result;
    ::new (&result.error._0) (const char*)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const char*const & AsError() const {
    assert(IsError());
    return error._0;
  }

  static UInt32Result Value(const uint32_t &_0) {
    UInt32Result result;
    ::new (&result.value._0) (uint32_t)(_0);
    result.tag = Tag::Value;
    return result;
  }

  bool IsValue() const {
    return tag == Tag::Value;
  }

  const uint32_t& AsValue() const {
    assert(IsValue());
    return value._0;
  }
};

/// C lang compatible representation of a rust `pattrns::NoteEvent`.
struct NoteEvent {
  uint8_t note;
  uint32_t instrument;
  float glide;
  float volume;
  float panning;
  float delay;
};

/// C lang compatible representation of a rust `Vec<pattrns::NoteEvent>`.
struct NoteEvents {
  const NoteEvent *events_ptr;
  uint32_t events_len;
};

/// C lang compatible representation of a rust `pattrns::ParameterChangeEvent`.
struct ParameterChangeEvent {
  uint32_t parameter;
  float value;
};

/// C lang compatible representation of a rust `Vec<pattrns::ParameterChangeEvent>`.
struct ParameterChangeEvents {
  const ParameterChangeEvent *events_ptr;
  uint32_t events_len;
};

/// C lang compatible pattern event representation, as passed to the consumer
/// callback in `run_pattern` and `run_pattern_until_time`.
struct PatternPlaybackEvent {
  uint64_t sample_time;
  uint64_t duration_in_samples;
  NoteEvents note_events;
  ParameterChangeEvents parameter_change_events;
};

using AllocFn = void*(*)(uint32_t, uint32_t);

using DeallocFn = void(*)(void*, uint32_t, uint32_t);

extern "C" {

/// Delete an error string from the Result wrappers.
void drop_error_string(const char *error);

/// Drop array of input parameters, created via `pattern_parameters`
void drop_parameter_set(ParameterSet *parameters);

/// Create a new pattern from the given script file path, using the given beat time and instrument.
/// The returned pattern result must be deleted via `drop_pattern` or `drop_error_string`.
PatternResult new_pattern_from_file(Timebase time_base,
                                    const uint32_t *instrument_id,
                                    const char *file_name);

/// Create a new pattern from the given script contents, using the given beat time and instrument.
/// The returned pattern result must be deleted via `drop_pattern` or `drop_error_string`.
PatternResult new_pattern_from_string(Timebase time_base,
                                      const uint32_t *instrument_id,
                                      const char *content,
                                      const char *content_name);

/// Create a new resetted clone from an existing pattern with the given timebase and instrument id.
/// The returned pattern result must be deleted via `drop_pattern` or `drop_error_string`.
PatternResult new_pattern_instance(Pattern *this_, Timebase time_base);

/// Get parameters of a pattern.
/// The returned result must be deleted via `drop_parameter_set` or `drop_error_string`.
ParameterSetResult pattern_parameters(Pattern *this_);

/// Set a single parameter value of a pattern.
VoidResult set_pattern_parameter_value(Pattern *this_, const char *id, double value);

/// Get length in samples of a pattern's step.
F64Result pattern_samples_per_step(Pattern *this_);

/// Get length of the pattern's rhythm (a full cycle, in steps).
UInt32Result pattern_step_count(Pattern *this_);

/// Set a new time base for a pattern.
VoidResult set_pattern_time_base(Pattern *this_, Timebase time_base);

/// Set trigger events for a pattern.
VoidResult set_pattern_trigger_event(Pattern *this_,
                                     const NoteEvent *note_events_ptr,
                                     uint32_t note_events_len);

/// Run pattern, consuming the single next due event only.
/// NB: Events are only valid within the callback, so they must be consumed
/// or copied when used outside of the callback.
VoidResult run_pattern(Pattern *this_,
                       void *callback_context,
                       void (*callback)(void*, const PatternPlaybackEvent*));

/// Run pattern, consuming all events which the pattern generated up to given sample time.
/// NB: Events are only valid within the callback, so they must be consumed
/// or copied when used outside of the callback.
VoidResult run_pattern_until_time(Pattern *this_,
                                  uint64_t time,
                                  void *callback_context,
                                  void (*callback)(void*, const PatternPlaybackEvent*));

/// Run/seek pattern, discarding all events up to the given time.
VoidResult advance_pattern_until_time(Pattern *this_, uint64_t time);

/// Delete a pattern which got allocated via `new_pattern_from_string/file`.
void drop_pattern(Pattern *pattern);

/// Initialize lib and set external allocator, which should be used instead of the system
/// allocator as global allocator (unless the "dhat-profiler" feature is enabled).
VoidResult initialize(AllocFn alloc, DeallocFn dealloc);

/// Finalize lib: no more calls into the library are allowed after this
VoidResult finalize();

}  // extern "C"

}  // namespace pattrns
